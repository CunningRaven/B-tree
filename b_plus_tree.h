#ifndef B_PLUS_TREE_H
#define B_PLUS_TREE_H

#include "gen_stk.h"
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

#define BPT_STK_CAP_INIT 10

typedef union {
  void *ptr;
  off_t off;
} bpt_t;

struct bpt_entry {
  bpt_t key;
  bpt_t val;
};

struct bpt_node {
  struct bpt_entry *entries;
};

/**
 * bpt_node_nkey: return current number of entries in the node
 */
static inline int bpt_node_nkey(struct bpt_node node, int order)
{
  return (int)node.entries[order].key.ptr;
}

static inline void bpt_node_set_nkey(struct bpt_node node, int order, int nkey)
{
  node.entries[order].key.ptr = (void *)nkey;
}

static inline struct bpt_node bpt_node_nxt(struct bpt_node node, int order)
{
  struct bpt_node rnt = { .entries = node.entries[order+1].key.ptr };
  return rnt;
}

static inline void bpt_node_set_nxt(struct bpt_node node, int order, struct bpt_node nxt)
{
  node.entries[order+1].key.ptr = nxt.entries;
}

static inline struct bpt_node bpt_node_prv(struct bpt_node node, int order)
{
  struct bpt_node rnt = { .entries = node.entries[order+1].val.ptr };
  return rnt;
}

static inline void bpt_node_set_prv(struct bpt_node node, int order, struct bpt_node prv)
{
  node.entries[order+1].val.ptr = prv.entries;
}

// B+ tree state
struct bpt_stat {
  struct bpt_node root_node;
  int order;
  int height;

  int old_leaf_nkey; //  entry count of the leaf node just after being splitted
  int new_leaf_nkey; // entry count of the new leaf node generated by splitting
  int old_inter_nkey; // key count of the internal node just after being splitted
  int new_inter_nkey; // key count of the new internal node generated by splitting
};

struct bpt_frm {
  struct bpt_node node;
  int offset;
};

enum BPT_RNT {
  BPT_NEXIST, // not exist
  BPT_PRED_FAIL,
  BPT_PRED_SUCCESS,
  BPT_ERROR
};

static inline void bpt_node_delete(struct bpt_node node)
{
  free(node.entries);
}

struct bpt_node bpt_node_new(int order, struct bpt_node prv, struct bpt_node nxt);
int bpt_init(struct bpt_stat *bstat, int order);
int bpt_search(bpt_t search_for, int (*cmp)(bpt_t, bpt_t), struct bpt_stat *bstat, struct bpt_node *leafp);
int bpt_searchr(bpt_t search_for, int (*cmp)(bpt_t, bpt_t),
    struct gen_stk *stk, int has_stk_init,
    struct bpt_stat *bstat, struct bpt_node *leafp);
int bpt_pred_1(bpt_t a, bpt_t b);
int bpt_pred_0(bpt_t a, bpt_t b);
int bpt_insert(struct bpt_entry new_entry, int (*cmp)(bpt_t, bpt_t), int (*pred)(bpt_t, bpt_t),
    struct gen_stk *stk, int has_stk_init,
    struct bpt_stat *bstat);
int bpt_delete(struct bpt_entry pair, int (*cmp)(bpt_t, bpt_t), int (*pred)(bpt_t, bpt_t),
    struct gen_stk *stk, int has_stk_init,
    struct bpt_stat *bstat);
int bpt_delete_entry(struct bpt_node leaf, int offset, struct gen_stk *stk, struct bpt_stat *bstat);

extern struct bpt_node bpt_null_node;
#endif
